
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>errors: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/satorunooshie/swipe-shukatu/pkg/errors/error_api.go (43.3%)</option>
				
				<option value="file1">github.com/satorunooshie/swipe-shukatu/pkg/errors/errors.go (0.0%)</option>
				
				<option value="file2">github.com/satorunooshie/swipe-shukatu/pkg/errors/levels.go (77.8%)</option>
				
				<option value="file3">github.com/satorunooshie/swipe-shukatu/pkg/errors/statuses.go (0.0%)</option>
				
				<option value="file4">github.com/satorunooshie/swipe-shukatu/pkg/infrastructure/mysql/repoimpl/job_repoimpl.go (44.1%)</option>
				
				<option value="file5">github.com/satorunooshie/swipe-shukatu/pkg/infrastructure/mysql/repoimpl/like_repoimpl.go (0.0%)</option>
				
				<option value="file6">github.com/satorunooshie/swipe-shukatu/pkg/infrastructure/mysql/repoimpl/ltd_repoimpl.go (23.1%)</option>
				
				<option value="file7">github.com/satorunooshie/swipe-shukatu/pkg/infrastructure/mysql/repoimpl/message_repoimpl.go (44.1%)</option>
				
				<option value="file8">github.com/satorunooshie/swipe-shukatu/pkg/infrastructure/mysql/repoimpl/recruit_repoimpl.go (25.0%)</option>
				
				<option value="file9">github.com/satorunooshie/swipe-shukatu/pkg/infrastructure/mysql/repoimpl/user_repoimpl.go (0.0%)</option>
				
				<option value="file10">github.com/satorunooshie/swipe-shukatu/pkg/interfaces/handler/job_handler.go (0.0%)</option>
				
				<option value="file11">github.com/satorunooshie/swipe-shukatu/pkg/interfaces/handler/like_handler.go (0.0%)</option>
				
				<option value="file12">github.com/satorunooshie/swipe-shukatu/pkg/interfaces/handler/ltd_handler.go (0.0%)</option>
				
				<option value="file13">github.com/satorunooshie/swipe-shukatu/pkg/interfaces/handler/message_handler.go (71.4%)</option>
				
				<option value="file14">github.com/satorunooshie/swipe-shukatu/pkg/interfaces/handler/mock_handler/mock_job_handler.go (0.0%)</option>
				
				<option value="file15">github.com/satorunooshie/swipe-shukatu/pkg/interfaces/handler/mock_handler/mock_like_handler.go (0.0%)</option>
				
				<option value="file16">github.com/satorunooshie/swipe-shukatu/pkg/interfaces/handler/mock_handler/mock_ltd_handler.go (0.0%)</option>
				
				<option value="file17">github.com/satorunooshie/swipe-shukatu/pkg/interfaces/handler/mock_handler/mock_message_handler.go (0.0%)</option>
				
				<option value="file18">github.com/satorunooshie/swipe-shukatu/pkg/interfaces/handler/mock_handler/mock_recruit_handler.go (0.0%)</option>
				
				<option value="file19">github.com/satorunooshie/swipe-shukatu/pkg/interfaces/handler/mock_handler/mock_user_handler.go (0.0%)</option>
				
				<option value="file20">github.com/satorunooshie/swipe-shukatu/pkg/interfaces/handler/recruit_handler.go (0.0%)</option>
				
				<option value="file21">github.com/satorunooshie/swipe-shukatu/pkg/interfaces/handler/user_handler.go (0.0%)</option>
				
				<option value="file22">github.com/satorunooshie/swipe-shukatu/pkg/interfaces/middleware/auth.go (0.0%)</option>
				
				<option value="file23">github.com/satorunooshie/swipe-shukatu/pkg/interfaces/middleware/cors.go (0.0%)</option>
				
				<option value="file24">github.com/satorunooshie/swipe-shukatu/pkg/usecase/job_usecase.go (0.0%)</option>
				
				<option value="file25">github.com/satorunooshie/swipe-shukatu/pkg/usecase/like_usecase.go (0.0%)</option>
				
				<option value="file26">github.com/satorunooshie/swipe-shukatu/pkg/usecase/ltd_usecase.go (0.0%)</option>
				
				<option value="file27">github.com/satorunooshie/swipe-shukatu/pkg/usecase/message_usecase.go (78.2%)</option>
				
				<option value="file28">github.com/satorunooshie/swipe-shukatu/pkg/usecase/mock_usecase/mock_job_usecase.go (0.0%)</option>
				
				<option value="file29">github.com/satorunooshie/swipe-shukatu/pkg/usecase/mock_usecase/mock_like_usecase.go (0.0%)</option>
				
				<option value="file30">github.com/satorunooshie/swipe-shukatu/pkg/usecase/mock_usecase/mock_ltd_usecase.go (0.0%)</option>
				
				<option value="file31">github.com/satorunooshie/swipe-shukatu/pkg/usecase/mock_usecase/mock_message_usecase.go (0.0%)</option>
				
				<option value="file32">github.com/satorunooshie/swipe-shukatu/pkg/usecase/mock_usecase/mock_recruit_usecase.go (0.0%)</option>
				
				<option value="file33">github.com/satorunooshie/swipe-shukatu/pkg/usecase/mock_usecase/mock_user_usecase.go (0.0%)</option>
				
				<option value="file34">github.com/satorunooshie/swipe-shukatu/pkg/usecase/recruit_usecase.go (0.0%)</option>
				
				<option value="file35">github.com/satorunooshie/swipe-shukatu/pkg/usecase/user_usecase.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package errors

import (
        "fmt"
        "net/http"

        "golang.org/x/xerrors"
)

func (e *appError) New(s ...string) AppError <span class="cov8" title="1">{
        m := e.code
        if len(s) != 0 </span><span class="cov0" title="0">{
                m = s[0]
        }</span>
        <span class="cov8" title="1">return e.new(m)</span>
}

func (e *appError) Errorf(format string, args ...interface{}) AppError <span class="cov0" title="0">{
        return e.New(fmt.Sprintf(format, args...))
}</span>

func (e *appError) Wrap(err error, s ...string) AppError <span class="cov8" title="1">{
        m := e.Code()
        if len(s) != 0 </span><span class="cov0" title="0">{
                m = s[0]
        }</span>
        <span class="cov8" title="1">ne := e.new(m)
        ne.next = err
        return ne</span>
}

func (e *appError) Wrapf(err error, format string, args ...interface{}) AppError <span class="cov0" title="0">{
        ne := e.new(fmt.Sprintf(format, args...))
        ne.next = err
        return ne
}</span>

func (e *appError) Messagef(args ...interface{}) AppError <span class="cov0" title="0">{
        e.infoMessage = fmt.Sprintf(e.infoMessage, args...)
        return e
}</span>

func (e *appError) Code() string <span class="cov8" title="1">{
        if e.code != `` </span><span class="cov8" title="1">{
                return e.code
        }</span>
        <span class="cov0" title="0">if next := AsAppError(e.next); next != nil </span><span class="cov0" title="0">{
                return next.Code()
        }</span>
        <span class="cov0" title="0">return `not_defined`</span>
}

func (e *appError) Status() int <span class="cov0" title="0">{
        if e.status != 0 </span><span class="cov0" title="0">{
                return e.status
        }</span>
        <span class="cov0" title="0">if next := AsAppError(e.next); next != nil </span><span class="cov0" title="0">{
                return next.Status()
        }</span>
        <span class="cov0" title="0">return http.StatusInternalServerError</span>
}

func (e *appError) InfoMessage() string <span class="cov0" title="0">{
        if e.infoMessage != `` </span><span class="cov0" title="0">{
                return e.InfoMessage()
        }</span>
        <span class="cov0" title="0">if next := AsAppError(e.next); next != nil </span><span class="cov0" title="0">{
                return next.InfoMessage()
        }</span>
        <span class="cov0" title="0">return defaultErrorMessage</span>
}

func (e *appError) IsServerError() bool <span class="cov0" title="0">{
        return e.Status() &gt;= http.StatusInternalServerError
}</span>

func (e *appError) new(s string) *appError <span class="cov8" title="1">{
        e.message = s
        e.frame = xerrors.Caller(2)
        return e
}</span>

func newError(code, s string) *appError <span class="cov8" title="1">{
        return &amp;appError{
                code:        code,
                infoMessage: s,
        }
}</span>

func newBadRequest(code, s string) AppError <span class="cov8" title="1">{
        e := newError(code, s)
        e.status = http.StatusBadRequest
        _ = e.Info()
        return e
}</span>

//nolint
func newUnauthorized(code, s string) AppError <span class="cov0" title="0">{
        e := newError(code, s)
        e.status = http.StatusUnauthorized
        _ = e.Info()
        return e
}</span>

//nolint
func newForbidden(code, s string) AppError <span class="cov0" title="0">{
        e := newError(code, s)
        e.status = http.StatusForbidden
        _ = e.Info()
        return e
}</span>

//nolint
func newConflict(code, s string) AppError <span class="cov0" title="0">{
        e := newError(code, s)
        e.status = http.StatusConflict
        _ = e.Info()
        return e
}</span>

func newNotFound(code, s string) AppError <span class="cov8" title="1">{
        e := newError(code, s)
        e.status = http.StatusNotFound
        _ = e.Info()
        return e
}</span>

func newInternalServerError(code, s string) AppError <span class="cov8" title="1">{
        e := newError(code, s)
        e.status = http.StatusInternalServerError
        _ = e.Critical()
        return e
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package errors

import (
        "fmt"

        "golang.org/x/xerrors"
)

type appError struct {
        // 標準を満たすエラー
        next    error
        message string
        frame   xerrors.Frame

        data  []map[string]interface{}
        level level

        code        string
        infoMessage string
        status      int
}

func (e *appError) Error() string <span class="cov0" title="0">{
        next := AsAppError(e.next)
        if next != nil </span><span class="cov0" title="0">{
                return next.Error()
        }</span>
        <span class="cov0" title="0">if e.next == nil </span><span class="cov0" title="0">{
                if e.message == `` </span><span class="cov0" title="0">{
                        return `no message`
                }</span>
                <span class="cov0" title="0">return e.message</span>
        }
        <span class="cov0" title="0">return e.next.Error()</span>
}

func (e *appError) Is(err error) bool <span class="cov0" title="0">{
        if er := AsAppError(err); er != nil </span><span class="cov0" title="0">{
                return e.Code() == er.Code()
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (e *appError) Unwrap() error <span class="cov0" title="0">{
        return e.next
}</span>

func (e *appError) Format(s fmt.State, v rune) <span class="cov0" title="0">{
        xerrors.FormatError(e, s, v)
}</span>

func (e *appError) FormatError(p xerrors.Printer) error <span class="cov0" title="0">{
        var s string
        if e.level != "" </span><span class="cov0" title="0">{
                s += fmt.Sprintf("[%s] ", e.level)
        }</span>
        <span class="cov0" title="0">if e.code != "" </span><span class="cov0" title="0">{
                s += fmt.Sprintf("[%s] ", e.code)
        }</span>
        <span class="cov0" title="0">if e.message != "" </span><span class="cov0" title="0">{
                s += e.message
        }</span>
        <span class="cov0" title="0">if len(e.data) != 0 </span><span class="cov0" title="0">{
                if s != "" </span><span class="cov0" title="0">{
                        s += "\n"
                }</span>
                <span class="cov0" title="0">s += fmt.Sprintf("data: %+v", e.data)</span>
        }
        <span class="cov0" title="0">p.Print(s)
        e.frame.Format(p)
        return e.next</span>
}

func (e *appError) Add(field string, data interface{}) AppError <span class="cov0" title="0">{
        if e.data == nil </span><span class="cov0" title="0">{
                e.data = make([]map[string]interface{}, 0)
        }</span>
        <span class="cov0" title="0">e.data = append(e.data, map[string]interface{}{field: data})
        return e</span>
}

func New(s string) AppError <span class="cov0" title="0">{
        return create(s)
}</span>

func Errorf(format string, args ...interface{}) AppError <span class="cov0" title="0">{
        return create(fmt.Sprintf(format, args...))
}</span>

func Wrap(err error, s ...string) AppError <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var m string
        if len(s) != 0 </span><span class="cov0" title="0">{
                m = s[0]
        }</span>
        <span class="cov0" title="0">e := create(m)
        e.next = err
        return e</span>
}

func Wrapf(format string, err error, args ...interface{}) AppError <span class="cov0" title="0">{
        e := create(fmt.Sprintf(format, args...))
        e.next = err
        return e
}</span>

//nolint
func AsAppError(err error) *appError <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">var e *appError
        if As(err, &amp;e) </span><span class="cov0" title="0">{
                return e
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func As(err error, target interface{}) bool <span class="cov0" title="0">{
        return xerrors.As(err, target)
}</span>

func create(s string) *appError <span class="cov0" title="0">{
        var e appError
        e.message = s
        e.frame = xerrors.Caller(2)
        return &amp;e
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package errors

type level string

const (
        levelPanic     level = "panic"
        levelEmergency level = "emergency"
        levelAlert     level = "alert"
        levelCritical  level = "critical"
        levelError     level = "error"
        levelWarn      level = "warn"
        levelNotice    level = "notice"
        levelInfo      level = "info"
        levelDebug     level = "debug"
)

func (e *appError) Panic() AppError <span class="cov8" title="1">{
        e.level = levelPanic
        return e
}</span>

func (e *appError) Critical() AppError <span class="cov8" title="1">{
        e.level = levelCritical
        return e
}</span>

func (e *appError) Warn() AppError <span class="cov8" title="1">{
        e.level = levelWarn
        return e
}</span>

func (e *appError) Info() AppError <span class="cov8" title="1">{
        e.level = levelInfo
        return e
}</span>

func (e *appError) IsPanic() bool <span class="cov8" title="1">{
        return e.checkLevel(levelPanic)
}</span>

func (e *appError) IsCritical() bool <span class="cov8" title="1">{
        return e.checkLevel(levelCritical)
}</span>

func (e *appError) IsWarn() bool <span class="cov8" title="1">{
        return e.checkLevel(levelWarn)
}</span>

func (e *appError) IsInfo() bool <span class="cov8" title="1">{
        return e.checkLevel(levelInfo)
}</span>

func (e *appError) checkLevel(l level) bool <span class="cov8" title="1">{
        if e.level != `` </span><span class="cov8" title="1">{
                return e.level == l
        }</span>
        <span class="cov0" title="0">next := AsAppError(e.next)
        if next != nil </span><span class="cov0" title="0">{
                next.checkLevel(l)
        }</span>
        // default critical
        <span class="cov0" title="0">return l == levelCritical</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package errors

import (
        "net/http"
)

func (e *appError) BadRequest() AppError <span class="cov0" title="0">{
        e.status = http.StatusBadRequest
        return e
}</span>

func (e *appError) Unauthorized() AppError <span class="cov0" title="0">{
        e.status = http.StatusUnauthorized
        return e
}</span>

func (e *appError) NotFound() AppError <span class="cov0" title="0">{
        e.status = http.StatusNotFound
        return e
}</span>

func (e *appError) InternalServerError() AppError <span class="cov0" title="0">{
        e.status = http.StatusInternalServerError
        return e
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">//go:generate mockgen -source=$GOFILE -destination=mock_$GOPACKAGE/mock_$GOFILE
package repoimpl

import (
        "context"
        "database/sql"
        "log"

        jobM "github.com/satorunooshie/swipe-shukatu/pkg/domain/model"
        jobR "github.com/satorunooshie/swipe-shukatu/pkg/domain/repository"
)

type jobRepoImpl struct {
        db *sql.DB
}

func NewJobRepoImpl(db *sql.DB) jobR.JobRepository <span class="cov8" title="1">{
        return &amp;jobRepoImpl{
                db,
        }
}</span>

// Select return job's id, name list.
func (jobI *jobRepoImpl) Select(ctx context.Context) ([]*jobM.Job, error) <span class="cov8" title="1">{
        rows, err := jobI.db.QueryContext(ctx, "SELECT id, name FROM m_job_type")
        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        log.Println("[INFO] job: ", err)
                        return nil, nil
                }</span>
                <span class="cov8" title="1">return nil, err</span>
        }
        <span class="cov8" title="1">return convertToJobs(rows)</span>
}

// Insert
func (jobI *jobRepoImpl) Insert(ctx context.Context, entity *jobM.Job) error <span class="cov0" title="0">{
        stmt, err := jobI.db.Prepare("INSERT INTO job () VALUES ()")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if _, err := stmt.Exec(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Update
func (jobI *jobRepoImpl) Update(ctx context.Context, entity *jobM.Job) error <span class="cov0" title="0">{
        stmt, err := jobI.db.Prepare("UPDATE job SET WHERE ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if _, err := stmt.Exec(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Delete
func (jobI *jobRepoImpl) Delete(ctx context.Context, entity *jobM.Job) error <span class="cov0" title="0">{
        stmt, err := jobI.db.Prepare("DELETE FROM job WHERE ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if _, err := stmt.Exec(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// convertToJobs
func convertToJobs(rows *sql.Rows) ([]*jobM.Job, error) <span class="cov8" title="1">{
        var jobs []*jobM.Job
        for rows.Next() </span><span class="cov8" title="1">{
                var job jobM.Job
                err := rows.Scan(&amp;job.ID, &amp;job.Name)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">jobs = append(jobs, &amp;job)</span>
        }
        <span class="cov8" title="1">return jobs, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">//go:generate mockgen -source=$GOFILE -destination=mock_$GOPACKAGE/mock_$GOFILE
package repoimpl

import (
        "context"
        "database/sql"
        "log"

        likeM "github.com/satorunooshie/swipe-shukatu/pkg/domain/model"
        likeR "github.com/satorunooshie/swipe-shukatu/pkg/domain/repository"
)

type likeRepoImpl struct {
        db *sql.DB
}

func NewLikeRepoImpl(db *sql.DB) likeR.LikeRepository <span class="cov0" title="0">{
        return &amp;likeRepoImpl{
                db,
        }
}</span>

// Select

func (likeI *likeRepoImpl) Select(ctx context.Context, UID string) ([]*likeM.Like, error) <span class="cov0" title="0">{
        rows, err := likeI.db.QueryContext(ctx, "SELECT user_id, recruit_id, created_at, updated_at FROM `like` WHERE user_id = ?", UID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        log.Println("[INFO] like: ", err)
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return convertToLikes(rows)</span>
}

// Insert
func (likeI *likeRepoImpl) Insert(ctx context.Context, entity *likeM.Like, UID string) error <span class="cov0" title="0">{
        query := "INSERT INTO `like`(user_id, recruit_id) VALUES (?,?)"
        stmt, err := likeI.db.PrepareContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer stmt.Close()
        if _, err := stmt.Exec(UID, entity.RecruitID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Update
func (likeI *likeRepoImpl) Update(ctx context.Context, entity *likeM.Like) error <span class="cov0" title="0">{
        stmt, err := likeI.db.PrepareContext(ctx, "UPDATE like SET WHERE ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer stmt.Close()
        if _, err := stmt.Exec(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Delete
func (likeI *likeRepoImpl) Delete(ctx context.Context, entity *likeM.Like) error <span class="cov0" title="0">{
        stmt, err := likeI.db.PrepareContext(ctx, "DELETE FROM like WHERE ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer stmt.Close()
        if _, err := stmt.Exec(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// convertToLike
func convertToLikes(rows *sql.Rows) ([]*likeM.Like, error) <span class="cov0" title="0">{
        var likes []*likeM.Like
        for rows.Next() </span><span class="cov0" title="0">{
                var like likeM.Like
                err := rows.Scan(
                        &amp;like.UID,
                        &amp;like.RecruitID,
                        &amp;like.CreatedAt,
                        &amp;like.UpdateddAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">likes = append(likes, &amp;like)</span>
        }
        <span class="cov0" title="0">return likes, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">//go:generate mockgen -source=$GOFILE -destination=mock_$GOPACKAGE/mock_$GOFILE
package repoimpl

import (
        "context"
        "database/sql"

        ltdM "github.com/satorunooshie/swipe-shukatu/pkg/domain/model"
        ltdR "github.com/satorunooshie/swipe-shukatu/pkg/domain/repository"
)

type ltdRepoImpl struct {
        db *sql.DB
}

func NewLtdRepoImpl(db *sql.DB) ltdR.LtdRepository <span class="cov8" title="1">{
        return &amp;ltdRepoImpl{
                db,
        }
}</span>

// Select
func (ltdI *ltdRepoImpl) Select(ctx context.Context) ([]*ltdM.Ltd, error) <span class="cov0" title="0">{
        rows, err := ltdI.db.Query("SELECT * FROM ltd")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return convertToLtd(rows)</span>
}

// SelectLtdNameByID return the name of Ltd by ID
func (ltdI *ltdRepoImpl) SelectLtdNameByID(ctx context.Context, ltdID int32) (string, error) <span class="cov8" title="1">{
        row := ltdI.db.QueryRowContext(ctx, "SELECT name FROM m_ltd WHERE id = ?", ltdID)
        var name string
        err := row.Scan(&amp;name)
        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return "", nil
                }</span>
                <span class="cov8" title="1">return "", err</span>
        }
        <span class="cov8" title="1">return name, nil</span>
}

// Insert
func (ltdI *ltdRepoImpl) Insert(ctx context.Context, entity *ltdM.Ltd) error <span class="cov0" title="0">{
        stmt, err := ltdI.db.Prepare("INSERT INTO ltd () VALUES ()")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if _, err := stmt.Exec(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Update
func (ltdI *ltdRepoImpl) Update(ctx context.Context, entity *ltdM.Ltd) error <span class="cov0" title="0">{
        stmt, err := ltdI.db.Prepare("UPDATE ltd SET WHERE ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if _, err := stmt.Exec(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Delete
func (ltdI *ltdRepoImpl) Delete(ctx context.Context, entity *ltdM.Ltd) error <span class="cov0" title="0">{
        stmt, err := ltdI.db.Prepare("DELETE FROM ltd WHERE ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if _, err := stmt.Exec(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// convertToLtd
func convertToLtd(rows *sql.Rows) ([]*ltdM.Ltd, error) <span class="cov0" title="0">{
        var ltds []*ltdM.Ltd
        for rows.Next() </span><span class="cov0" title="0">{
                var ltd *ltdM.Ltd
                err := rows.Scan(
                // Need to scan field
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">ltds = append(ltds, ltd)</span>
        }
        <span class="cov0" title="0">return ltds, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">//go:generate mockgen -source=$GOFILE -destination=mock_$GOPACKAGE/mock_$GOFILE
package repoimpl

import (
        "context"
        "database/sql"
        "log"

        messageM "github.com/satorunooshie/swipe-shukatu/pkg/domain/model"
        messageR "github.com/satorunooshie/swipe-shukatu/pkg/domain/repository"
)

type messageRepoImpl struct {
        db *sql.DB
}

func NewMessageRepoImpl(db *sql.DB) messageR.MessageRepository <span class="cov8" title="1">{
        return &amp;messageRepoImpl{
                db,
        }
}</span>

// Select return a slice of Message by recruit ID
func (messageI *messageRepoImpl) Select(ctx context.Context, rID int32) ([]*messageM.Message, error) <span class="cov8" title="1">{
        rows, err := messageI.db.QueryContext(ctx, "SELECT content, image_path, created_at FROM message WHERE recruit_id = ?", rID)
        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        log.Println("[INFO] message: ", err)
                        return nil, nil
                }</span>
                <span class="cov8" title="1">return nil, err</span>
        }
        <span class="cov8" title="1">return convertToMessages(rows)</span>
}

// Insert
func (messageI *messageRepoImpl) Insert(ctx context.Context, entity *messageM.Message) error <span class="cov0" title="0">{
        stmt, err := messageI.db.Prepare("INSERT INTO message () VALUES ()")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if _, err := stmt.Exec(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Update
func (messageI *messageRepoImpl) Update(ctx context.Context, entity *messageM.Message) error <span class="cov0" title="0">{
        stmt, err := messageI.db.Prepare("UPDATE message SET WHERE ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if _, err := stmt.Exec(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Delete
func (messageI *messageRepoImpl) Delete(ctx context.Context, entity *messageM.Message) error <span class="cov0" title="0">{
        stmt, err := messageI.db.Prepare("DELETE FROM message WHERE ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if _, err := stmt.Exec(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// convertToMessages
func convertToMessages(rows *sql.Rows) ([]*messageM.Message, error) <span class="cov8" title="1">{
        var messages []*messageM.Message
        for rows.Next() </span><span class="cov8" title="1">{
                var message messageM.Message
                err := rows.Scan(
                        &amp;message.Content,
                        &amp;message.ImagePath,
                        &amp;message.CreatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">messages = append(messages, &amp;message)</span>
        }
        <span class="cov8" title="1">return messages, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">//go:generate mockgen -source=$GOFILE -destination=mock_$GOPACKAGE/mock_$GOFILE
package repoimpl

import (
        "context"
        "database/sql"
        "log"

        recruitM "github.com/satorunooshie/swipe-shukatu/pkg/domain/model"
        recruitR "github.com/satorunooshie/swipe-shukatu/pkg/domain/repository"
)

type recruitRepoImpl struct {
        db *sql.DB
}

func NewRecruitRepoImpl(db *sql.DB) recruitR.RecruitRepository <span class="cov8" title="1">{
        return &amp;recruitRepoImpl{
                db,
        }
}</span>

// Select
func (recruitI *recruitRepoImpl) Select(ctx context.Context) ([]*recruitM.Recruit, error) <span class="cov0" title="0">{
        rows, err := recruitI.db.Query("SELECT * FROM recruit")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return convertToRecruits(rows)</span>
}

// SelectDetail fetch the recruit.
func (recruitI *recruitRepoImpl) SelectRecruitForMessage(ctx context.Context, rID int32) (*recruitM.Recruit, error) <span class="cov8" title="1">{
        q := "SELECT id, ltd_id, job_type_id FROM recruit WHERE id = ? AND deleted_at IS NULL"
        var r recruitM.Recruit
        err := recruitI.db.QueryRowContext(ctx, q, rID).Scan(
                &amp;r.ID,
                &amp;r.LtdID,
                &amp;r.JobTypeID,
        )
        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        log.Println("[INFO] recruit: ", err)
                        return nil, nil
                }</span>
                <span class="cov8" title="1">return nil, err</span>
        }
        <span class="cov8" title="1">return &amp;r, nil</span>
}

// Insert
func (recruitI *recruitRepoImpl) Insert(ctx context.Context, entity *recruitM.Recruit) error <span class="cov0" title="0">{
        stmt, err := recruitI.db.Prepare("INSERT INTO recruit () VALUES ()")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if _, err := stmt.Exec(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Update
func (recruitI *recruitRepoImpl) Update(ctx context.Context, entity *recruitM.Recruit) error <span class="cov0" title="0">{
        stmt, err := recruitI.db.Prepare("UPDATE recruit SET WHERE ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if _, err := stmt.Exec(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Delete
func (recruitI *recruitRepoImpl) Delete(ctx context.Context, entity *recruitM.Recruit) error <span class="cov0" title="0">{
        stmt, err := recruitI.db.Prepare("DELETE FROM recruit WHERE ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if _, err := stmt.Exec(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// convertToRecruits
func convertToRecruits(rows *sql.Rows) ([]*recruitM.Recruit, error) <span class="cov0" title="0">{
        var recruits []*recruitM.Recruit
        for rows.Next() </span><span class="cov0" title="0">{
                var recruit *recruitM.Recruit
                err := rows.Scan(
                // Need to scan field
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">recruits = append(recruits, recruit)</span>
        }
        <span class="cov0" title="0">return recruits, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">//go:generate mockgen -source=$GOFILE -destination=mock_$GOPACKAGE/mock_$GOFILE
package repoimpl

import (
        "context"
        "database/sql"

        userM "github.com/satorunooshie/swipe-shukatu/pkg/domain/model"
        userR "github.com/satorunooshie/swipe-shukatu/pkg/domain/repository"
)

type userRepoImpl struct {
        db *sql.DB
}

func NewUserRepoImpl(db *sql.DB) userR.UserRepository <span class="cov0" title="0">{
        return &amp;userRepoImpl{
                db,
        }
}</span>

// Select
func (userI *userRepoImpl) Select(ctx context.Context) ([]*userM.User, error) <span class="cov0" title="0">{
        rows, err := userI.db.Query("SELECT * FROM user")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return convertToUser(rows)</span>
}

// Insert
func (userI *userRepoImpl) Insert(ctx context.Context, entity *userM.User) error <span class="cov0" title="0">{
        stmt, err := userI.db.Prepare("INSERT INTO user () VALUES ()")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if _, err := stmt.Exec(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Update
func (userI *userRepoImpl) Update(ctx context.Context, entity *userM.User) error <span class="cov0" title="0">{
        stmt, err := userI.db.Prepare("UPDATE user SET WHERE ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if _, err := stmt.Exec(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Delete
func (userI *userRepoImpl) Delete(ctx context.Context, entity *userM.User) error <span class="cov0" title="0">{
        stmt, err := userI.db.Prepare("DELETE FROM user WHERE ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if _, err := stmt.Exec(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// convertToUser
func convertToUser(rows *sql.Rows) ([]*userM.User, error) <span class="cov0" title="0">{
        var users []*userM.User
        for rows.Next() </span><span class="cov0" title="0">{
                var user *userM.User
                err := rows.Scan(
                // Need to scan field
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">users = append(users, user)</span>
        }
        <span class="cov0" title="0">return users, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">//go:generate mockgen -source=$GOFILE -destination=mock_$GOPACKAGE/mock_$GOFILE
package handler

import (
        "net/http"

        jobU "github.com/satorunooshie/swipe-shukatu/pkg/usecase"
)

type JobHandler interface {
        HandleSelect() http.HandlerFunc
        HandleInsert() http.HandlerFunc
        HandleUpdate() http.HandlerFunc
        HandleDelete() http.HandlerFunc
}

type jobHandler struct {
        jobUseCase jobU.JobUseCase
}

// NewJobHandler
func NewJobHandler(jobU jobU.JobUseCase) JobHandler <span class="cov0" title="0">{
        return &amp;jobHandler{
                jobUseCase: jobU,
        }
}</span>

// HandleSelect
func (jobH *jobHandler) HandleSelect() http.HandlerFunc <span class="cov0" title="0">{
        return func(writer http.ResponseWriter, request *http.Request) </span><span class="cov0" title="0">{
                panic("do something")</span>
        }
}

// HandleInsert
func (jobH *jobHandler) HandleInsert() http.HandlerFunc <span class="cov0" title="0">{
        return func(writer http.ResponseWriter, request *http.Request) </span><span class="cov0" title="0">{
                panic("do something")</span>
        }
}

// HandleUpdate
func (jobH *jobHandler) HandleUpdate() http.HandlerFunc <span class="cov0" title="0">{
        return func(writer http.ResponseWriter, request *http.Request) </span><span class="cov0" title="0">{
                panic("do something")</span>
        }
}

// HandleDelete
func (jobH *jobHandler) HandleDelete() http.HandlerFunc <span class="cov0" title="0">{
        return func(writer http.ResponseWriter, request *http.Request) </span><span class="cov0" title="0">{
                panic("do something")</span>
        }
}

// JobRequest
type JobRequest struct { // nolint
        // Need to implement field
}

// JobResponse
type JobResponse struct { // nolint
        // Need to implement field
}
</pre>
		
		<pre class="file" id="file11" style="display: none">//go:generate mockgen -source=$GOFILE -destination=mock_$GOPACKAGE/mock_$GOFILE
package handler

import (
        "context"
        "encoding/json"
        "log"
        "net/http"
        "time"

        "github.com/satorunooshie/swipe-shukatu/pkg/dcontext"
        likeM "github.com/satorunooshie/swipe-shukatu/pkg/domain/model"
        likeU "github.com/satorunooshie/swipe-shukatu/pkg/usecase"
)

type LikeHandler interface {
        HandleSelect() http.HandlerFunc
        HandleInsert() http.HandlerFunc
        HandleUpdate() http.HandlerFunc
        HandleDelete() http.HandlerFunc
}

type likeHandler struct {
        likeUseCase likeU.LikeUseCase
}

// NewLikeHandler
func NewLikeHandler(likeU likeU.LikeUseCase) LikeHandler <span class="cov0" title="0">{
        return &amp;likeHandler{
                likeUseCase: likeU,
        }
}</span>

// HandleSelect
func (likeH *likeHandler) HandleSelect() http.HandlerFunc <span class="cov0" title="0">{
        return func(writer http.ResponseWriter, request *http.Request) </span><span class="cov0" title="0">{
                ctx := request.Context()
                ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
                defer cancel()
                UID := dcontext.GetUIDFromContext(ctx)
                likes, err := likeH.likeUseCase.Select(ctx, UID)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("[ERROR] failed to Select from like: %v", err.Error())
                        http.Error(writer, err.Error(), http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov0" title="0">res := make([]*LikeResponse, len(likes))
                for i, l := range likes </span><span class="cov0" title="0">{
                        var ls LikeResponse
                        ls.RecruitID = l.RecruitID
                        ls.CreatedAt = l.CreatedAt
                        res[i] = &amp;ls
                }</span>
                <span class="cov0" title="0">var respms LikeResponses
                respms.Likes = res
                jsonresponse, err := json.Marshal(respms)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("[ERROR] failed to marshal likes: %v", err.Error())
                        http.Error(writer, err.Error(), http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov0" title="0">writer.WriteHeader(http.StatusOK)
                writer.Header().Set("Content-Type", "application/json")
                writer.Write(jsonresponse)</span>
        }
}

// HandleInsert
func (likeH *likeHandler) HandleInsert() http.HandlerFunc <span class="cov0" title="0">{
        return func(writer http.ResponseWriter, request *http.Request) </span><span class="cov0" title="0">{
                defer request.Body.Close()
                like := new(likeM.Like)
                if err := json.NewDecoder(request.Body).Decode(&amp;like); err != nil </span><span class="cov0" title="0">{
                        log.Printf("[ERROR] failed to JsonDecord: %v", err.Error())
                        http.Error(writer, err.Error(), http.StatusInternalServerError)
                        return
                }</span>
                // TODO::読み込んだjsonデータのバリデーションがほしい
                <span class="cov0" title="0">ctx := request.Context()
                ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
                defer cancel()
                UID := dcontext.GetUIDFromContext(ctx)
                if UID == "" </span><span class="cov0" title="0">{
                        log.Printf("[ERROR] failed to GetUID: ")
                        http.Error(writer, "Could not get UID", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov0" title="0">err := likeH.likeUseCase.Insert(ctx, like, UID)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("[ERROR] failed to Insert: %v", err.Error())
                        http.Error(writer, err.Error(), http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov0" title="0">writer.WriteHeader(http.StatusCreated)</span>
        }
}

type Rid struct {
        RID string
}

// HandleUpdate
func (likeH *likeHandler) HandleUpdate() http.HandlerFunc <span class="cov0" title="0">{
        return func(writer http.ResponseWriter, request *http.Request) </span><span class="cov0" title="0">{
                panic("do something")</span>
        }
}

// HandleDelete
func (likeH *likeHandler) HandleDelete() http.HandlerFunc <span class="cov0" title="0">{
        return func(writer http.ResponseWriter, request *http.Request) </span><span class="cov0" title="0">{
                panic("do something")</span>
        }
}

// LikeRequest
type LikeRequest struct { // nolint
        // Need to implement field
}

type LikeResponses struct {
        Likes []*LikeResponse `json:"likes"`
}

// LikeResponse ...
type LikeResponse struct {
        RecruitID int32     `json:"recruit_id"`
        CreatedAt time.Time `json:"created_at"`
}
</pre>
		
		<pre class="file" id="file12" style="display: none">//go:generate mockgen -source=$GOFILE -destination=mock_$GOPACKAGE/mock_$GOFILE
package handler

import (
        "net/http"

        ltdU "github.com/satorunooshie/swipe-shukatu/pkg/usecase"
)

type LtdHandler interface {
        HandleSelect() http.HandlerFunc
        HandleInsert() http.HandlerFunc
        HandleUpdate() http.HandlerFunc
        HandleDelete() http.HandlerFunc
}

type ltdHandler struct {
        ltdUseCase ltdU.LtdUseCase
}

// NewLtdHandler
func NewLtdHandler(ltdU ltdU.LtdUseCase) LtdHandler <span class="cov0" title="0">{
        return &amp;ltdHandler{
                ltdUseCase: ltdU,
        }
}</span>

// HandleSelect
func (ltdH *ltdHandler) HandleSelect() http.HandlerFunc <span class="cov0" title="0">{
        return func(writer http.ResponseWriter, request *http.Request) </span><span class="cov0" title="0">{
                panic("do something")</span>
        }
}

// HandleInsert
func (ltdH *ltdHandler) HandleInsert() http.HandlerFunc <span class="cov0" title="0">{
        return func(writer http.ResponseWriter, request *http.Request) </span><span class="cov0" title="0">{
                panic("do something")</span>
        }
}

// HandleUpdate
func (ltdH *ltdHandler) HandleUpdate() http.HandlerFunc <span class="cov0" title="0">{
        return func(writer http.ResponseWriter, request *http.Request) </span><span class="cov0" title="0">{
                panic("do something")</span>
        }
}

// HandleDelete
func (ltdH *ltdHandler) HandleDelete() http.HandlerFunc <span class="cov0" title="0">{
        return func(writer http.ResponseWriter, request *http.Request) </span><span class="cov0" title="0">{
                panic("do something")</span>
        }
}

// LtdRequest
type LtdRequest struct { // nolint
        // Need to implement field
}

// LtdResponse
type LtdResponse struct { // nolint
        // Need to implement field
}
</pre>
		
		<pre class="file" id="file13" style="display: none">//go:generate mockgen -source=$GOFILE -destination=mock_$GOPACKAGE/mock_$GOFILE
package handler

import (
        "context"
        "encoding/json"
        "log"
        "net/http"
        "strconv"
        "strings"
        "time"

        messageU "github.com/satorunooshie/swipe-shukatu/pkg/usecase"
)

type MessageHandler interface {
        HandleSelect() http.HandlerFunc
        HandleInsert() http.HandlerFunc
        HandleUpdate() http.HandlerFunc
        HandleDelete() http.HandlerFunc
}

type messageHandler struct {
        messageUseCase messageU.MessageUseCase
}

// NewMessageHandler
func NewMessageHandler(messageU messageU.MessageUseCase) MessageHandler <span class="cov8" title="1">{
        return &amp;messageHandler{
                messageUseCase: messageU,
        }
}</span>

// HandleSelect
func (messageH *messageHandler) HandleSelect() http.HandlerFunc <span class="cov8" title="1">{
        return func(writer http.ResponseWriter, request *http.Request) </span><span class="cov8" title="1">{
                ctx := request.Context()
                ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
                defer cancel()
                rID, err := strconv.Atoi(strings.TrimPrefix(request.URL.Path, "/message/"))
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("invalid recruitID: %s", err)
                        http.Error(writer, "recruitID is invalid", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">ms, err := messageH.messageUseCase.Select(ctx, int32(rID))
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("[ERROR] failed to fetch messages by recruit ID: %v", err.Error())
                        http.Error(writer, err.Error(), http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">mrs := make([]*MessageResponse, len(ms))
                for i, m := range ms </span><span class="cov8" title="1">{
                        var mr MessageResponse
                        mr.LtdID = m.LtdID
                        mr.RecruitID = m.RecruitID
                        mr.Name = m.Name
                        mr.JobType = m.JobType
                        mr.Content = m.Content
                        mr.Image = m.Image
                        mr.CreatedAt = m.CreatedAt
                        mrs[i] = &amp;mr
                }</span>
                <span class="cov8" title="1">var respms MessageResponses
                respms.Messages = mrs
                jrespms, err := json.Marshal(respms)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("[ERROR] failed to marshal messages: %v", err.Error())
                        http.Error(writer, err.Error(), http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">writer.WriteHeader(http.StatusOK)
                writer.Header().Set("Content-Type", "application/json")
                writer.Write(jrespms)</span>
        }
}

// HandleInsert
func (messageH *messageHandler) HandleInsert() http.HandlerFunc <span class="cov0" title="0">{
        return func(writer http.ResponseWriter, request *http.Request) </span><span class="cov0" title="0">{
                panic("do something")</span>
        }
}

// HandleUpdate
func (messageH *messageHandler) HandleUpdate() http.HandlerFunc <span class="cov0" title="0">{
        return func(writer http.ResponseWriter, request *http.Request) </span><span class="cov0" title="0">{
                panic("do something")</span>
        }
}

// HandleDelete
func (messageH *messageHandler) HandleDelete() http.HandlerFunc <span class="cov0" title="0">{
        return func(writer http.ResponseWriter, request *http.Request) </span><span class="cov0" title="0">{
                panic("do something")</span>
        }
}

// MessageRequest
type MessageRequest struct { // nolint
        // Need to implement field
}

// MessageResponse ...
type MessageResponses struct {
        Messages []*MessageResponse `json:"messages"`
}

// MessageResponse ...
type MessageResponse struct {
        LtdID     int32     `json:"ltd_id"`
        RecruitID int32     `json:"recruit_id"`
        Name      string    `json:"name"`
        JobType   string    `json:"job_type"`
        Content   string    `json:"content"`
        Image     string    `json:"image"`
        CreatedAt time.Time `json:"created_at"`
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: job_handler.go

// Package mock_handler is a generated GoMock package.
package mock_handler

import (
        http "net/http"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockJobHandler is a mock of JobHandler interface.
type MockJobHandler struct {
        ctrl     *gomock.Controller
        recorder *MockJobHandlerMockRecorder
}

// MockJobHandlerMockRecorder is the mock recorder for MockJobHandler.
type MockJobHandlerMockRecorder struct {
        mock *MockJobHandler
}

// NewMockJobHandler creates a new mock instance.
func NewMockJobHandler(ctrl *gomock.Controller) *MockJobHandler <span class="cov0" title="0">{
        mock := &amp;MockJobHandler{ctrl: ctrl}
        mock.recorder = &amp;MockJobHandlerMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockJobHandler) EXPECT() *MockJobHandlerMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// HandleDelete mocks base method.
func (m *MockJobHandler) HandleDelete() http.HandlerFunc <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "HandleDelete")
        ret0, _ := ret[0].(http.HandlerFunc)
        return ret0
}</span>

// HandleDelete indicates an expected call of HandleDelete.
func (mr *MockJobHandlerMockRecorder) HandleDelete() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HandleDelete", reflect.TypeOf((*MockJobHandler)(nil).HandleDelete))
}</span>

// HandleInsert mocks base method.
func (m *MockJobHandler) HandleInsert() http.HandlerFunc <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "HandleInsert")
        ret0, _ := ret[0].(http.HandlerFunc)
        return ret0
}</span>

// HandleInsert indicates an expected call of HandleInsert.
func (mr *MockJobHandlerMockRecorder) HandleInsert() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HandleInsert", reflect.TypeOf((*MockJobHandler)(nil).HandleInsert))
}</span>

// HandleSelect mocks base method.
func (m *MockJobHandler) HandleSelect() http.HandlerFunc <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "HandleSelect")
        ret0, _ := ret[0].(http.HandlerFunc)
        return ret0
}</span>

// HandleSelect indicates an expected call of HandleSelect.
func (mr *MockJobHandlerMockRecorder) HandleSelect() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HandleSelect", reflect.TypeOf((*MockJobHandler)(nil).HandleSelect))
}</span>

// HandleUpdate mocks base method.
func (m *MockJobHandler) HandleUpdate() http.HandlerFunc <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "HandleUpdate")
        ret0, _ := ret[0].(http.HandlerFunc)
        return ret0
}</span>

// HandleUpdate indicates an expected call of HandleUpdate.
func (mr *MockJobHandlerMockRecorder) HandleUpdate() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HandleUpdate", reflect.TypeOf((*MockJobHandler)(nil).HandleUpdate))
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: like_handler.go

// Package mock_handler is a generated GoMock package.
package mock_handler

import (
        http "net/http"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockLikeHandler is a mock of LikeHandler interface.
type MockLikeHandler struct {
        ctrl     *gomock.Controller
        recorder *MockLikeHandlerMockRecorder
}

// MockLikeHandlerMockRecorder is the mock recorder for MockLikeHandler.
type MockLikeHandlerMockRecorder struct {
        mock *MockLikeHandler
}

// NewMockLikeHandler creates a new mock instance.
func NewMockLikeHandler(ctrl *gomock.Controller) *MockLikeHandler <span class="cov0" title="0">{
        mock := &amp;MockLikeHandler{ctrl: ctrl}
        mock.recorder = &amp;MockLikeHandlerMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockLikeHandler) EXPECT() *MockLikeHandlerMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// HandleDelete mocks base method.
func (m *MockLikeHandler) HandleDelete() http.HandlerFunc <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "HandleDelete")
        ret0, _ := ret[0].(http.HandlerFunc)
        return ret0
}</span>

// HandleDelete indicates an expected call of HandleDelete.
func (mr *MockLikeHandlerMockRecorder) HandleDelete() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HandleDelete", reflect.TypeOf((*MockLikeHandler)(nil).HandleDelete))
}</span>

// HandleInsert mocks base method.
func (m *MockLikeHandler) HandleInsert() http.HandlerFunc <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "HandleInsert")
        ret0, _ := ret[0].(http.HandlerFunc)
        return ret0
}</span>

// HandleInsert indicates an expected call of HandleInsert.
func (mr *MockLikeHandlerMockRecorder) HandleInsert() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HandleInsert", reflect.TypeOf((*MockLikeHandler)(nil).HandleInsert))
}</span>

// HandleSelect mocks base method.
func (m *MockLikeHandler) HandleSelect() http.HandlerFunc <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "HandleSelect")
        ret0, _ := ret[0].(http.HandlerFunc)
        return ret0
}</span>

// HandleSelect indicates an expected call of HandleSelect.
func (mr *MockLikeHandlerMockRecorder) HandleSelect() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HandleSelect", reflect.TypeOf((*MockLikeHandler)(nil).HandleSelect))
}</span>

// HandleUpdate mocks base method.
func (m *MockLikeHandler) HandleUpdate() http.HandlerFunc <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "HandleUpdate")
        ret0, _ := ret[0].(http.HandlerFunc)
        return ret0
}</span>

// HandleUpdate indicates an expected call of HandleUpdate.
func (mr *MockLikeHandlerMockRecorder) HandleUpdate() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HandleUpdate", reflect.TypeOf((*MockLikeHandler)(nil).HandleUpdate))
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ltd_handler.go

// Package mock_handler is a generated GoMock package.
package mock_handler

import (
        http "net/http"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockLtdHandler is a mock of LtdHandler interface.
type MockLtdHandler struct {
        ctrl     *gomock.Controller
        recorder *MockLtdHandlerMockRecorder
}

// MockLtdHandlerMockRecorder is the mock recorder for MockLtdHandler.
type MockLtdHandlerMockRecorder struct {
        mock *MockLtdHandler
}

// NewMockLtdHandler creates a new mock instance.
func NewMockLtdHandler(ctrl *gomock.Controller) *MockLtdHandler <span class="cov0" title="0">{
        mock := &amp;MockLtdHandler{ctrl: ctrl}
        mock.recorder = &amp;MockLtdHandlerMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockLtdHandler) EXPECT() *MockLtdHandlerMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// HandleDelete mocks base method.
func (m *MockLtdHandler) HandleDelete() http.HandlerFunc <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "HandleDelete")
        ret0, _ := ret[0].(http.HandlerFunc)
        return ret0
}</span>

// HandleDelete indicates an expected call of HandleDelete.
func (mr *MockLtdHandlerMockRecorder) HandleDelete() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HandleDelete", reflect.TypeOf((*MockLtdHandler)(nil).HandleDelete))
}</span>

// HandleInsert mocks base method.
func (m *MockLtdHandler) HandleInsert() http.HandlerFunc <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "HandleInsert")
        ret0, _ := ret[0].(http.HandlerFunc)
        return ret0
}</span>

// HandleInsert indicates an expected call of HandleInsert.
func (mr *MockLtdHandlerMockRecorder) HandleInsert() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HandleInsert", reflect.TypeOf((*MockLtdHandler)(nil).HandleInsert))
}</span>

// HandleSelect mocks base method.
func (m *MockLtdHandler) HandleSelect() http.HandlerFunc <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "HandleSelect")
        ret0, _ := ret[0].(http.HandlerFunc)
        return ret0
}</span>

// HandleSelect indicates an expected call of HandleSelect.
func (mr *MockLtdHandlerMockRecorder) HandleSelect() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HandleSelect", reflect.TypeOf((*MockLtdHandler)(nil).HandleSelect))
}</span>

// HandleUpdate mocks base method.
func (m *MockLtdHandler) HandleUpdate() http.HandlerFunc <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "HandleUpdate")
        ret0, _ := ret[0].(http.HandlerFunc)
        return ret0
}</span>

// HandleUpdate indicates an expected call of HandleUpdate.
func (mr *MockLtdHandlerMockRecorder) HandleUpdate() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HandleUpdate", reflect.TypeOf((*MockLtdHandler)(nil).HandleUpdate))
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: message_handler.go

// Package mock_handler is a generated GoMock package.
package mock_handler

import (
        http "net/http"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockMessageHandler is a mock of MessageHandler interface.
type MockMessageHandler struct {
        ctrl     *gomock.Controller
        recorder *MockMessageHandlerMockRecorder
}

// MockMessageHandlerMockRecorder is the mock recorder for MockMessageHandler.
type MockMessageHandlerMockRecorder struct {
        mock *MockMessageHandler
}

// NewMockMessageHandler creates a new mock instance.
func NewMockMessageHandler(ctrl *gomock.Controller) *MockMessageHandler <span class="cov0" title="0">{
        mock := &amp;MockMessageHandler{ctrl: ctrl}
        mock.recorder = &amp;MockMessageHandlerMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockMessageHandler) EXPECT() *MockMessageHandlerMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// HandleDelete mocks base method.
func (m *MockMessageHandler) HandleDelete() http.HandlerFunc <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "HandleDelete")
        ret0, _ := ret[0].(http.HandlerFunc)
        return ret0
}</span>

// HandleDelete indicates an expected call of HandleDelete.
func (mr *MockMessageHandlerMockRecorder) HandleDelete() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HandleDelete", reflect.TypeOf((*MockMessageHandler)(nil).HandleDelete))
}</span>

// HandleInsert mocks base method.
func (m *MockMessageHandler) HandleInsert() http.HandlerFunc <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "HandleInsert")
        ret0, _ := ret[0].(http.HandlerFunc)
        return ret0
}</span>

// HandleInsert indicates an expected call of HandleInsert.
func (mr *MockMessageHandlerMockRecorder) HandleInsert() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HandleInsert", reflect.TypeOf((*MockMessageHandler)(nil).HandleInsert))
}</span>

// HandleSelect mocks base method.
func (m *MockMessageHandler) HandleSelect() http.HandlerFunc <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "HandleSelect")
        ret0, _ := ret[0].(http.HandlerFunc)
        return ret0
}</span>

// HandleSelect indicates an expected call of HandleSelect.
func (mr *MockMessageHandlerMockRecorder) HandleSelect() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HandleSelect", reflect.TypeOf((*MockMessageHandler)(nil).HandleSelect))
}</span>

// HandleUpdate mocks base method.
func (m *MockMessageHandler) HandleUpdate() http.HandlerFunc <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "HandleUpdate")
        ret0, _ := ret[0].(http.HandlerFunc)
        return ret0
}</span>

// HandleUpdate indicates an expected call of HandleUpdate.
func (mr *MockMessageHandlerMockRecorder) HandleUpdate() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HandleUpdate", reflect.TypeOf((*MockMessageHandler)(nil).HandleUpdate))
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: recruit_handler.go

// Package mock_handler is a generated GoMock package.
package mock_handler

import (
        http "net/http"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockRecruitHandler is a mock of RecruitHandler interface.
type MockRecruitHandler struct {
        ctrl     *gomock.Controller
        recorder *MockRecruitHandlerMockRecorder
}

// MockRecruitHandlerMockRecorder is the mock recorder for MockRecruitHandler.
type MockRecruitHandlerMockRecorder struct {
        mock *MockRecruitHandler
}

// NewMockRecruitHandler creates a new mock instance.
func NewMockRecruitHandler(ctrl *gomock.Controller) *MockRecruitHandler <span class="cov0" title="0">{
        mock := &amp;MockRecruitHandler{ctrl: ctrl}
        mock.recorder = &amp;MockRecruitHandlerMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRecruitHandler) EXPECT() *MockRecruitHandlerMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// HandleDelete mocks base method.
func (m *MockRecruitHandler) HandleDelete() http.HandlerFunc <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "HandleDelete")
        ret0, _ := ret[0].(http.HandlerFunc)
        return ret0
}</span>

// HandleDelete indicates an expected call of HandleDelete.
func (mr *MockRecruitHandlerMockRecorder) HandleDelete() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HandleDelete", reflect.TypeOf((*MockRecruitHandler)(nil).HandleDelete))
}</span>

// HandleInsert mocks base method.
func (m *MockRecruitHandler) HandleInsert() http.HandlerFunc <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "HandleInsert")
        ret0, _ := ret[0].(http.HandlerFunc)
        return ret0
}</span>

// HandleInsert indicates an expected call of HandleInsert.
func (mr *MockRecruitHandlerMockRecorder) HandleInsert() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HandleInsert", reflect.TypeOf((*MockRecruitHandler)(nil).HandleInsert))
}</span>

// HandleSelect mocks base method.
func (m *MockRecruitHandler) HandleSelect() http.HandlerFunc <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "HandleSelect")
        ret0, _ := ret[0].(http.HandlerFunc)
        return ret0
}</span>

// HandleSelect indicates an expected call of HandleSelect.
func (mr *MockRecruitHandlerMockRecorder) HandleSelect() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HandleSelect", reflect.TypeOf((*MockRecruitHandler)(nil).HandleSelect))
}</span>

// HandleUpdate mocks base method.
func (m *MockRecruitHandler) HandleUpdate() http.HandlerFunc <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "HandleUpdate")
        ret0, _ := ret[0].(http.HandlerFunc)
        return ret0
}</span>

// HandleUpdate indicates an expected call of HandleUpdate.
func (mr *MockRecruitHandlerMockRecorder) HandleUpdate() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HandleUpdate", reflect.TypeOf((*MockRecruitHandler)(nil).HandleUpdate))
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: user_handler.go

// Package mock_handler is a generated GoMock package.
package mock_handler

import (
        http "net/http"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockUserHandler is a mock of UserHandler interface.
type MockUserHandler struct {
        ctrl     *gomock.Controller
        recorder *MockUserHandlerMockRecorder
}

// MockUserHandlerMockRecorder is the mock recorder for MockUserHandler.
type MockUserHandlerMockRecorder struct {
        mock *MockUserHandler
}

// NewMockUserHandler creates a new mock instance.
func NewMockUserHandler(ctrl *gomock.Controller) *MockUserHandler <span class="cov0" title="0">{
        mock := &amp;MockUserHandler{ctrl: ctrl}
        mock.recorder = &amp;MockUserHandlerMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUserHandler) EXPECT() *MockUserHandlerMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// HandleDelete mocks base method.
func (m *MockUserHandler) HandleDelete() http.HandlerFunc <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "HandleDelete")
        ret0, _ := ret[0].(http.HandlerFunc)
        return ret0
}</span>

// HandleDelete indicates an expected call of HandleDelete.
func (mr *MockUserHandlerMockRecorder) HandleDelete() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HandleDelete", reflect.TypeOf((*MockUserHandler)(nil).HandleDelete))
}</span>

// HandleInsert mocks base method.
func (m *MockUserHandler) HandleInsert() http.HandlerFunc <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "HandleInsert")
        ret0, _ := ret[0].(http.HandlerFunc)
        return ret0
}</span>

// HandleInsert indicates an expected call of HandleInsert.
func (mr *MockUserHandlerMockRecorder) HandleInsert() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HandleInsert", reflect.TypeOf((*MockUserHandler)(nil).HandleInsert))
}</span>

// HandleSelect mocks base method.
func (m *MockUserHandler) HandleSelect() http.HandlerFunc <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "HandleSelect")
        ret0, _ := ret[0].(http.HandlerFunc)
        return ret0
}</span>

// HandleSelect indicates an expected call of HandleSelect.
func (mr *MockUserHandlerMockRecorder) HandleSelect() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HandleSelect", reflect.TypeOf((*MockUserHandler)(nil).HandleSelect))
}</span>

// HandleUpdate mocks base method.
func (m *MockUserHandler) HandleUpdate() http.HandlerFunc <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "HandleUpdate")
        ret0, _ := ret[0].(http.HandlerFunc)
        return ret0
}</span>

// HandleUpdate indicates an expected call of HandleUpdate.
func (mr *MockUserHandlerMockRecorder) HandleUpdate() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HandleUpdate", reflect.TypeOf((*MockUserHandler)(nil).HandleUpdate))
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">//go:generate mockgen -source=$GOFILE -destination=mock_$GOPACKAGE/mock_$GOFILE
package handler

import (
        "net/http"

        recruitU "github.com/satorunooshie/swipe-shukatu/pkg/usecase"
)

type RecruitHandler interface {
        HandleSelect() http.HandlerFunc
        HandleInsert() http.HandlerFunc
        HandleUpdate() http.HandlerFunc
        HandleDelete() http.HandlerFunc
}

type recruitHandler struct {
        recruitUseCase recruitU.RecruitUseCase
}

// NewRecruitHandler
func NewRecruitHandler(recruitU recruitU.RecruitUseCase) RecruitHandler <span class="cov0" title="0">{
        return &amp;recruitHandler{
                recruitUseCase: recruitU,
        }
}</span>

// HandleSelect
func (recruitH *recruitHandler) HandleSelect() http.HandlerFunc <span class="cov0" title="0">{
        return func(writer http.ResponseWriter, request *http.Request) </span><span class="cov0" title="0">{
                panic("do something")</span>
        }
}

// HandleInsert
func (recruitH *recruitHandler) HandleInsert() http.HandlerFunc <span class="cov0" title="0">{
        return func(writer http.ResponseWriter, request *http.Request) </span><span class="cov0" title="0">{
                panic("do something")</span>
        }
}

// HandleUpdate
func (recruitH *recruitHandler) HandleUpdate() http.HandlerFunc <span class="cov0" title="0">{
        return func(writer http.ResponseWriter, request *http.Request) </span><span class="cov0" title="0">{
                panic("do something")</span>
        }
}

// HandleDelete
func (recruitH *recruitHandler) HandleDelete() http.HandlerFunc <span class="cov0" title="0">{
        return func(writer http.ResponseWriter, request *http.Request) </span><span class="cov0" title="0">{
                panic("do something")</span>
        }
}

// RecruitRequest
type RecruitRequest struct { // nolint
        // Need to implement field
}

// RecruitResponse
type RecruitResponse struct { // nolint
        // Need to implement field
}
</pre>
		
		<pre class="file" id="file21" style="display: none">//go:generate mockgen -source=$GOFILE -destination=mock_$GOPACKAGE/mock_$GOFILE
package handler

import (
        "net/http"

        userU "github.com/satorunooshie/swipe-shukatu/pkg/usecase"
)

type UserHandler interface {
        HandleSelect() http.HandlerFunc
        HandleInsert() http.HandlerFunc
        HandleUpdate() http.HandlerFunc
        HandleDelete() http.HandlerFunc
}

type userHandler struct {
        userUseCase userU.UserUseCase
}

// NewUserHandler returns a new UserHandler
func NewUserHandler(userU userU.UserUseCase) UserHandler <span class="cov0" title="0">{
        return &amp;userHandler{
                userUseCase: userU,
        }
}</span>

// HandleSelect ...
func (userH *userHandler) HandleSelect() http.HandlerFunc <span class="cov0" title="0">{
        return func(writer http.ResponseWriter, request *http.Request) </span><span class="cov0" title="0">{
                panic("do something")</span>
        }
}

// HandleInsert ...
func (userH *userHandler) HandleInsert() http.HandlerFunc <span class="cov0" title="0">{
        return func(writer http.ResponseWriter, request *http.Request) </span><span class="cov0" title="0">{
                panic("do something")</span>
        }
}

// HandleUpdate ...
func (userH *userHandler) HandleUpdate() http.HandlerFunc <span class="cov0" title="0">{
        return func(writer http.ResponseWriter, request *http.Request) </span><span class="cov0" title="0">{
                panic("do something")</span>
        }
}

// HandleDelete ...
func (userH *userHandler) HandleDelete() http.HandlerFunc <span class="cov0" title="0">{
        return func(writer http.ResponseWriter, request *http.Request) </span><span class="cov0" title="0">{
                panic("do something")</span>
        }
}

//nolint
// UserRequest
type UserRequest struct {
        // Need to implement field
}

//nolint
// UserResponse
type UserResponse struct {
        // Need to implement field
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package middleware

import (
        "context"
        "errors"
        "log"
        "net/http"
        "os"
        "strings"

        "google.golang.org/api/option"

        firebase "firebase.google.com/go"

        "github.com/satorunooshie/swipe-shukatu/pkg/dcontext"
)

//nolint
func Auth(next http.HandlerFunc) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                authHeader := r.Header.Get("Authorization")
                idToken := strings.Replace(authHeader, "Bearer ", "", 1)
                if idToken == "" </span><span class="cov0" title="0">{
                        log.Printf("[INFO] auth::Auth: %v\n", errors.New("header is not set"))
                        w.WriteHeader(http.StatusBadRequest)
                        // TODO: Delete debug code instead return json error message
                        _, _ = w.Write([]byte("empty token\n"))
                        return
                }</span>

                <span class="cov0" title="0">path, err := getFilePath()
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("[ERROR] auth::Auth::getFilePath: %v\n", err)
                        w.WriteHeader(http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov0" title="0">opt := option.WithCredentialsFile(path)

                ctx := r.Context()
                if ctx == nil </span><span class="cov0" title="0">{
                        ctx = context.Background()
                }</span>

                <span class="cov0" title="0">app, err := firebase.NewApp(ctx, nil, opt)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("[ERROR] auth::Auth::firebase.NewApp: %v\n", err)
                        w.WriteHeader(http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">auth, err := app.Auth(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("[ERROR] auth::Auth::app.Auth: %v\n", err)
                        w.WriteHeader(http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">token, err := auth.VerifyIDToken(ctx, idToken)
                if err != nil </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusUnauthorized)
                        // TODO: Delete debug code instead return json error message
                        _, _ = w.Write([]byte("error verifying ID token\n"))
                        return
                }</span>
                <span class="cov0" title="0">dcontext.SetUID(ctx, token.UID)
                log.Printf("[INFO] Verified ID token: %v\n", token)
                next.ServeHTTP(w, r.WithContext(ctx))</span>
        }
}

// NOTE: 実行パスが違うのでトリミング
func getFilePath() (string, error) <span class="cov0" title="0">{
        const (
                dirname  = "swipe-shukatu"
                filename = "firebase-sdk.json"
        )
        cp, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">idx := strings.LastIndex(cp, dirname)
        return cp[:(idx+len(dirname))] + "/" + filename, nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package middleware

import (
        "log"
        "net/http"
)

func Get(next http.HandlerFunc) http.HandlerFunc <span class="cov0" title="0">{
        return httpMethod(next, http.MethodGet)
}</span>

//nolint
func Post(next http.HandlerFunc) http.HandlerFunc <span class="cov0" title="0">{
        return httpMethod(next, http.MethodPost)
}</span>

//nolint
func Put(next http.HandlerFunc) http.HandlerFunc <span class="cov0" title="0">{
        return httpMethod(next, http.MethodPut)
}</span>

//nolint
func Delete(next http.HandlerFunc) http.HandlerFunc <span class="cov0" title="0">{
        return httpMethod(next, http.MethodDelete)
}</span>

func httpMethod(next http.HandlerFunc, method string) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                const client = "http://localhost:3000"
                w.Header().Add("Access-Control-Allow-Origin", client)
                w.Header().Add("Access-Control-Allow-Headers", "Content-Type, Accept, Origin, Authorization")
                w.Header().Set("Access-Control-Allow-Credentials", "true")
                if r.Method == http.MethodOptions </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">if r.Method != method </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusMethodNotAllowed)
                        if _, err := w.Write([]byte("Method not allowed")); err != nil </span><span class="cov0" title="0">{
                                log.Println(err)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
                <span class="cov0" title="0">w.Header().Add("Content-Type", "application/json; charset=utf-8")
                next(w, r)</span>
        }
}
</pre>
		
		<pre class="file" id="file24" style="display: none">//go:generate mockgen -source=$GOFILE -destination=mock_$GOPACKAGE/mock_$GOFILE
package usecase

import (
        "context"

        jobM "github.com/satorunooshie/swipe-shukatu/pkg/domain/model"
        jobR "github.com/satorunooshie/swipe-shukatu/pkg/domain/repository"
)

type JobUseCase interface {
        Select(ctx context.Context) ([]*jobM.Job, error)
        Insert(ctx context.Context, entity *jobM.Job) error
        Update(ctx context.Context, entity *jobM.Job) error
        Delete(ctx context.Context, entity *jobM.Job) error
}

type jobUseCase struct {
        jobRepository jobR.JobRepository
}

// NewJobUsecase
func NewJobUsecase(jobR jobR.JobRepository) JobUseCase <span class="cov0" title="0">{
        return &amp;jobUseCase{
                jobRepository: jobR,
        }
}</span>

// Select
func (jobU *jobUseCase) Select(ctx context.Context) ([]*jobM.Job, error) <span class="cov0" title="0">{
        jobs, err := jobU.jobRepository.Select(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return jobs, nil</span>
}

// Insert
func (jobU *jobUseCase) Insert(ctx context.Context, entity *jobM.Job) error <span class="cov0" title="0">{
        err := jobU.jobRepository.Insert(ctx, entity)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Update
func (jobU *jobUseCase) Update(ctx context.Context, entity *jobM.Job) error <span class="cov0" title="0">{
        err := jobU.jobRepository.Update(ctx, entity)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Delete
func (jobU *jobUseCase) Delete(ctx context.Context, entity *jobM.Job) error <span class="cov0" title="0">{
        err := jobU.jobRepository.Delete(ctx, entity)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">//go:generate mockgen -source=$GOFILE -destination=mock_$GOPACKAGE/mock_$GOFILE
package usecase

import (
        "context"

        "github.com/satorunooshie/swipe-shukatu/pkg/domain/model"
        likeM "github.com/satorunooshie/swipe-shukatu/pkg/domain/model"
        likeR "github.com/satorunooshie/swipe-shukatu/pkg/domain/repository"
)

type LikeUseCase interface {
        Select(ctx context.Context, UID string) ([]*likeM.Like, error)
        Insert(ctx context.Context, entity *likeM.Like, UID string) error
        Update(ctx context.Context, entity *likeM.Like) error
        Delete(ctx context.Context, entity *likeM.Like) error
}

type likeUseCase struct {
        likeRepository likeR.LikeRepository
}

// NewLikeUsecase
func NewLikeUsecase(likeR likeR.LikeRepository) LikeUseCase <span class="cov0" title="0">{
        return &amp;likeUseCase{
                likeRepository: likeR,
        }
}</span>

// Select
func (likeU *likeUseCase) Select(ctx context.Context, UID string) ([]*likeM.Like, error) <span class="cov0" title="0">{
        var likes []*model.Like
        likes, err := likeU.likeRepository.Select(ctx, UID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return likes, nil</span>
}

// Insert
func (likeU *likeUseCase) Insert(ctx context.Context, entity *likeM.Like, UID string) error <span class="cov0" title="0">{
        err := likeU.likeRepository.Insert(ctx, entity, UID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Update
func (likeU *likeUseCase) Update(ctx context.Context, entity *likeM.Like) error <span class="cov0" title="0">{
        err := likeU.likeRepository.Update(ctx, entity)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Delete
func (likeU *likeUseCase) Delete(ctx context.Context, entity *likeM.Like) error <span class="cov0" title="0">{
        err := likeU.likeRepository.Delete(ctx, entity)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">//go:generate mockgen -source=$GOFILE -destination=mock_$GOPACKAGE/mock_$GOFILE
package usecase

import (
        "context"

        ltdM "github.com/satorunooshie/swipe-shukatu/pkg/domain/model"
        ltdR "github.com/satorunooshie/swipe-shukatu/pkg/domain/repository"
)

type LtdUseCase interface {
        Select(ctx context.Context) ([]*ltdM.Ltd, error)
        Insert(ctx context.Context, entity *ltdM.Ltd) error
        Update(ctx context.Context, entity *ltdM.Ltd) error
        Delete(ctx context.Context, entity *ltdM.Ltd) error
}

type ltdUseCase struct {
        ltdRepository ltdR.LtdRepository
}

// NewLtdUsecase
func NewLtdUsecase(ltdR ltdR.LtdRepository) LtdUseCase <span class="cov0" title="0">{
        return &amp;ltdUseCase{
                ltdRepository: ltdR,
        }
}</span>

// Select
func (ltdU *ltdUseCase) Select(ctx context.Context) ([]*ltdM.Ltd, error) <span class="cov0" title="0">{
        ltds, err := ltdU.ltdRepository.Select(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ltds, nil</span>
}

// Insert
func (ltdU *ltdUseCase) Insert(ctx context.Context, entity *ltdM.Ltd) error <span class="cov0" title="0">{
        err := ltdU.ltdRepository.Insert(ctx, entity)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Update
func (ltdU *ltdUseCase) Update(ctx context.Context, entity *ltdM.Ltd) error <span class="cov0" title="0">{
        err := ltdU.ltdRepository.Update(ctx, entity)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Delete
func (ltdU *ltdUseCase) Delete(ctx context.Context, entity *ltdM.Ltd) error <span class="cov0" title="0">{
        err := ltdU.ltdRepository.Delete(ctx, entity)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">//go:generate mockgen -source=$GOFILE -destination=mock_$GOPACKAGE/mock_$GOFILE
package usecase

import (
        "context"
        "log"
        "time"

        "github.com/satorunooshie/swipe-shukatu/pkg/domain/model"
        "github.com/satorunooshie/swipe-shukatu/pkg/domain/repository"
        "golang.org/x/sync/errgroup"
)

type MessageUseCase interface {
        Select(ctx context.Context, rID int32) ([]*MessageResponse, error)
        Insert(ctx context.Context, entity *model.Message) error
        Update(ctx context.Context, entity *model.Message) error
        Delete(ctx context.Context, entity *model.Message) error
}

type messageUseCase struct {
        jobRepository     repository.JobRepository
        ltdRepository     repository.LtdRepository
        messageRepository repository.MessageRepository
        recruitRepository repository.RecruitRepository
}

// NewMessageUsecase
func NewMessageUsecase(
        jobR repository.JobRepository,
        ltdR repository.LtdRepository,
        messageR repository.MessageRepository,
        recR repository.RecruitRepository,
) MessageUseCase <span class="cov8" title="1">{
        return &amp;messageUseCase{
                jobRepository:     jobR,
                ltdRepository:     ltdR,
                messageRepository: messageR,
                recruitRepository: recR,
        }
}</span>

// Select
func (messageU *messageUseCase) Select(ctx context.Context, rID int32) ([]*MessageResponse, error) <span class="cov8" title="1">{
        var (
                messages []*model.Message
                rec      *model.Recruit
                err      error
        )

        js, err := messageU.jobRepository.Select(ctx)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">jm := make(map[int32]string)

        for _, j := range js </span><span class="cov8" title="1">{
                jm[j.ID] = j.Name
        }</span>

        <span class="cov8" title="1">eg, ctx := errgroup.WithContext(ctx)
        // TODO::認証middlewareが入った段階でここでuser idでの絞り込みも追加する
        eg.Go(func() error </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        log.Println("[WARN]fetch message's goroutine is canceld")
                        return ctx.Err()</span>
                default:<span class="cov8" title="1">
                        messages, err = messageU.messageRepository.Select(ctx, rID) // content, image_path, created_at
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        <span class="cov8" title="1">return nil</span>
                }
        })

        <span class="cov8" title="1">eg.Go(func() error </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        log.Println("[WARN] fetch recruit's goroutine is canceld")
                        return ctx.Err()</span>
                default:<span class="cov8" title="1">
                        rec, err = messageU.recruitRepository.SelectRecruitForMessage(ctx, rID) // id, ltd_id, job_type_id
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        <span class="cov8" title="1">return nil</span>
                }
        })

        <span class="cov8" title="1">if err = eg.Wait(); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">ltdName, err := messageU.ltdRepository.SelectLtdNameByID(ctx, rec.LtdID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">ms := make([]*MessageResponse, len(messages))
        for i, m := range messages </span><span class="cov8" title="1">{
                var mr MessageResponse
                job := jm[rec.JobTypeID]
                mr.LtdID = rec.LtdID
                mr.RecruitID = rID
                mr.Name = ltdName
                mr.JobType = job
                mr.Content = m.Content
                mr.Image = m.ImagePath
                mr.CreatedAt = m.CreatedAt
                ms[i] = &amp;mr
        }</span>
        <span class="cov8" title="1">return ms, nil</span>
}

// Insert
func (messageU *messageUseCase) Insert(ctx context.Context, entity *model.Message) error <span class="cov0" title="0">{
        err := messageU.messageRepository.Insert(ctx, entity)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Update
func (messageU *messageUseCase) Update(ctx context.Context, entity *model.Message) error <span class="cov0" title="0">{
        err := messageU.messageRepository.Update(ctx, entity)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Delete
func (messageU *messageUseCase) Delete(ctx context.Context, entity *model.Message) error <span class="cov0" title="0">{
        err := messageU.messageRepository.Delete(ctx, entity)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type MessageResponse struct {
        LtdID     int32
        RecruitID int32
        Name      string
        JobType   string
        Content   string
        Image     string
        CreatedAt time.Time
}
</pre>
		
		<pre class="file" id="file28" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: job_usecase.go

// Package mock_usecase is a generated GoMock package.
package mock_usecase

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        model "github.com/satorunooshie/swipe-shukatu/pkg/domain/model"
)

// MockJobUseCase is a mock of JobUseCase interface.
type MockJobUseCase struct {
        ctrl     *gomock.Controller
        recorder *MockJobUseCaseMockRecorder
}

// MockJobUseCaseMockRecorder is the mock recorder for MockJobUseCase.
type MockJobUseCaseMockRecorder struct {
        mock *MockJobUseCase
}

// NewMockJobUseCase creates a new mock instance.
func NewMockJobUseCase(ctrl *gomock.Controller) *MockJobUseCase <span class="cov0" title="0">{
        mock := &amp;MockJobUseCase{ctrl: ctrl}
        mock.recorder = &amp;MockJobUseCaseMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockJobUseCase) EXPECT() *MockJobUseCaseMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Delete mocks base method.
func (m *MockJobUseCase) Delete(ctx context.Context, entity *model.Job) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Delete", ctx, entity)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Delete indicates an expected call of Delete.
func (mr *MockJobUseCaseMockRecorder) Delete(ctx, entity interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockJobUseCase)(nil).Delete), ctx, entity)
}</span>

// Insert mocks base method.
func (m *MockJobUseCase) Insert(ctx context.Context, entity *model.Job) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Insert", ctx, entity)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Insert indicates an expected call of Insert.
func (mr *MockJobUseCaseMockRecorder) Insert(ctx, entity interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Insert", reflect.TypeOf((*MockJobUseCase)(nil).Insert), ctx, entity)
}</span>

// Select mocks base method.
func (m *MockJobUseCase) Select(ctx context.Context) ([]*model.Job, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Select", ctx)
        ret0, _ := ret[0].([]*model.Job)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Select indicates an expected call of Select.
func (mr *MockJobUseCaseMockRecorder) Select(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Select", reflect.TypeOf((*MockJobUseCase)(nil).Select), ctx)
}</span>

// Update mocks base method.
func (m *MockJobUseCase) Update(ctx context.Context, entity *model.Job) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Update", ctx, entity)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Update indicates an expected call of Update.
func (mr *MockJobUseCaseMockRecorder) Update(ctx, entity interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockJobUseCase)(nil).Update), ctx, entity)
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: like_usecase.go

// Package mock_usecase is a generated GoMock package.
package mock_usecase

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        model "github.com/satorunooshie/swipe-shukatu/pkg/domain/model"
)

// MockLikeUseCase is a mock of LikeUseCase interface.
type MockLikeUseCase struct {
        ctrl     *gomock.Controller
        recorder *MockLikeUseCaseMockRecorder
}

// MockLikeUseCaseMockRecorder is the mock recorder for MockLikeUseCase.
type MockLikeUseCaseMockRecorder struct {
        mock *MockLikeUseCase
}

// NewMockLikeUseCase creates a new mock instance.
func NewMockLikeUseCase(ctrl *gomock.Controller) *MockLikeUseCase <span class="cov0" title="0">{
        mock := &amp;MockLikeUseCase{ctrl: ctrl}
        mock.recorder = &amp;MockLikeUseCaseMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockLikeUseCase) EXPECT() *MockLikeUseCaseMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Delete mocks base method.
func (m *MockLikeUseCase) Delete(ctx context.Context, entity *model.Like) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Delete", ctx, entity)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Delete indicates an expected call of Delete.
func (mr *MockLikeUseCaseMockRecorder) Delete(ctx, entity interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockLikeUseCase)(nil).Delete), ctx, entity)
}</span>

// Insert mocks base method.
func (m *MockLikeUseCase) Insert(ctx context.Context, entity *model.Like, UID string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Insert", ctx, entity, UID)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Insert indicates an expected call of Insert.
func (mr *MockLikeUseCaseMockRecorder) Insert(ctx, entity, UID interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Insert", reflect.TypeOf((*MockLikeUseCase)(nil).Insert), ctx, entity, UID)
}</span>

// Select mocks base method.
func (m *MockLikeUseCase) Select(ctx context.Context, UID string) ([]*model.Like, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Select", ctx, UID)
        ret0, _ := ret[0].([]*model.Like)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Select indicates an expected call of Select.
func (mr *MockLikeUseCaseMockRecorder) Select(ctx, UID interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Select", reflect.TypeOf((*MockLikeUseCase)(nil).Select), ctx, UID)
}</span>

// Update mocks base method.
func (m *MockLikeUseCase) Update(ctx context.Context, entity *model.Like) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Update", ctx, entity)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Update indicates an expected call of Update.
func (mr *MockLikeUseCaseMockRecorder) Update(ctx, entity interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockLikeUseCase)(nil).Update), ctx, entity)
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ltd_usecase.go

// Package mock_usecase is a generated GoMock package.
package mock_usecase

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        model "github.com/satorunooshie/swipe-shukatu/pkg/domain/model"
)

// MockLtdUseCase is a mock of LtdUseCase interface.
type MockLtdUseCase struct {
        ctrl     *gomock.Controller
        recorder *MockLtdUseCaseMockRecorder
}

// MockLtdUseCaseMockRecorder is the mock recorder for MockLtdUseCase.
type MockLtdUseCaseMockRecorder struct {
        mock *MockLtdUseCase
}

// NewMockLtdUseCase creates a new mock instance.
func NewMockLtdUseCase(ctrl *gomock.Controller) *MockLtdUseCase <span class="cov0" title="0">{
        mock := &amp;MockLtdUseCase{ctrl: ctrl}
        mock.recorder = &amp;MockLtdUseCaseMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockLtdUseCase) EXPECT() *MockLtdUseCaseMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Delete mocks base method.
func (m *MockLtdUseCase) Delete(ctx context.Context, entity *model.Ltd) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Delete", ctx, entity)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Delete indicates an expected call of Delete.
func (mr *MockLtdUseCaseMockRecorder) Delete(ctx, entity interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockLtdUseCase)(nil).Delete), ctx, entity)
}</span>

// Insert mocks base method.
func (m *MockLtdUseCase) Insert(ctx context.Context, entity *model.Ltd) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Insert", ctx, entity)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Insert indicates an expected call of Insert.
func (mr *MockLtdUseCaseMockRecorder) Insert(ctx, entity interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Insert", reflect.TypeOf((*MockLtdUseCase)(nil).Insert), ctx, entity)
}</span>

// Select mocks base method.
func (m *MockLtdUseCase) Select(ctx context.Context) ([]*model.Ltd, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Select", ctx)
        ret0, _ := ret[0].([]*model.Ltd)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Select indicates an expected call of Select.
func (mr *MockLtdUseCaseMockRecorder) Select(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Select", reflect.TypeOf((*MockLtdUseCase)(nil).Select), ctx)
}</span>

// Update mocks base method.
func (m *MockLtdUseCase) Update(ctx context.Context, entity *model.Ltd) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Update", ctx, entity)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Update indicates an expected call of Update.
func (mr *MockLtdUseCaseMockRecorder) Update(ctx, entity interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockLtdUseCase)(nil).Update), ctx, entity)
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: message_usecase.go

// Package mock_usecase is a generated GoMock package.
package mock_usecase

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        model "github.com/satorunooshie/swipe-shukatu/pkg/domain/model"
        usecase "github.com/satorunooshie/swipe-shukatu/pkg/usecase"
)

// MockMessageUseCase is a mock of MessageUseCase interface.
type MockMessageUseCase struct {
        ctrl     *gomock.Controller
        recorder *MockMessageUseCaseMockRecorder
}

// MockMessageUseCaseMockRecorder is the mock recorder for MockMessageUseCase.
type MockMessageUseCaseMockRecorder struct {
        mock *MockMessageUseCase
}

// NewMockMessageUseCase creates a new mock instance.
func NewMockMessageUseCase(ctrl *gomock.Controller) *MockMessageUseCase <span class="cov0" title="0">{
        mock := &amp;MockMessageUseCase{ctrl: ctrl}
        mock.recorder = &amp;MockMessageUseCaseMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockMessageUseCase) EXPECT() *MockMessageUseCaseMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Delete mocks base method.
func (m *MockMessageUseCase) Delete(ctx context.Context, entity *model.Message) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Delete", ctx, entity)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Delete indicates an expected call of Delete.
func (mr *MockMessageUseCaseMockRecorder) Delete(ctx, entity interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockMessageUseCase)(nil).Delete), ctx, entity)
}</span>

// Insert mocks base method.
func (m *MockMessageUseCase) Insert(ctx context.Context, entity *model.Message) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Insert", ctx, entity)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Insert indicates an expected call of Insert.
func (mr *MockMessageUseCaseMockRecorder) Insert(ctx, entity interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Insert", reflect.TypeOf((*MockMessageUseCase)(nil).Insert), ctx, entity)
}</span>

// Select mocks base method.
func (m *MockMessageUseCase) Select(ctx context.Context, rID int32) ([]*usecase.MessageResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Select", ctx, rID)
        ret0, _ := ret[0].([]*usecase.MessageResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Select indicates an expected call of Select.
func (mr *MockMessageUseCaseMockRecorder) Select(ctx, rID interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Select", reflect.TypeOf((*MockMessageUseCase)(nil).Select), ctx, rID)
}</span>

// Update mocks base method.
func (m *MockMessageUseCase) Update(ctx context.Context, entity *model.Message) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Update", ctx, entity)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Update indicates an expected call of Update.
func (mr *MockMessageUseCaseMockRecorder) Update(ctx, entity interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockMessageUseCase)(nil).Update), ctx, entity)
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: recruit_usecase.go

// Package mock_usecase is a generated GoMock package.
package mock_usecase

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        model "github.com/satorunooshie/swipe-shukatu/pkg/domain/model"
)

// MockRecruitUseCase is a mock of RecruitUseCase interface.
type MockRecruitUseCase struct {
        ctrl     *gomock.Controller
        recorder *MockRecruitUseCaseMockRecorder
}

// MockRecruitUseCaseMockRecorder is the mock recorder for MockRecruitUseCase.
type MockRecruitUseCaseMockRecorder struct {
        mock *MockRecruitUseCase
}

// NewMockRecruitUseCase creates a new mock instance.
func NewMockRecruitUseCase(ctrl *gomock.Controller) *MockRecruitUseCase <span class="cov0" title="0">{
        mock := &amp;MockRecruitUseCase{ctrl: ctrl}
        mock.recorder = &amp;MockRecruitUseCaseMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRecruitUseCase) EXPECT() *MockRecruitUseCaseMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Delete mocks base method.
func (m *MockRecruitUseCase) Delete(ctx context.Context, entity *model.Recruit) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Delete", ctx, entity)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Delete indicates an expected call of Delete.
func (mr *MockRecruitUseCaseMockRecorder) Delete(ctx, entity interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockRecruitUseCase)(nil).Delete), ctx, entity)
}</span>

// Insert mocks base method.
func (m *MockRecruitUseCase) Insert(ctx context.Context, entity *model.Recruit) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Insert", ctx, entity)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Insert indicates an expected call of Insert.
func (mr *MockRecruitUseCaseMockRecorder) Insert(ctx, entity interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Insert", reflect.TypeOf((*MockRecruitUseCase)(nil).Insert), ctx, entity)
}</span>

// Select mocks base method.
func (m *MockRecruitUseCase) Select(ctx context.Context) ([]*model.Recruit, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Select", ctx)
        ret0, _ := ret[0].([]*model.Recruit)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Select indicates an expected call of Select.
func (mr *MockRecruitUseCaseMockRecorder) Select(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Select", reflect.TypeOf((*MockRecruitUseCase)(nil).Select), ctx)
}</span>

// Update mocks base method.
func (m *MockRecruitUseCase) Update(ctx context.Context, entity *model.Recruit) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Update", ctx, entity)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Update indicates an expected call of Update.
func (mr *MockRecruitUseCaseMockRecorder) Update(ctx, entity interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockRecruitUseCase)(nil).Update), ctx, entity)
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: user_usecase.go

// Package mock_usecase is a generated GoMock package.
package mock_usecase

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        model "github.com/satorunooshie/swipe-shukatu/pkg/domain/model"
)

// MockUserUseCase is a mock of UserUseCase interface.
type MockUserUseCase struct {
        ctrl     *gomock.Controller
        recorder *MockUserUseCaseMockRecorder
}

// MockUserUseCaseMockRecorder is the mock recorder for MockUserUseCase.
type MockUserUseCaseMockRecorder struct {
        mock *MockUserUseCase
}

// NewMockUserUseCase creates a new mock instance.
func NewMockUserUseCase(ctrl *gomock.Controller) *MockUserUseCase <span class="cov0" title="0">{
        mock := &amp;MockUserUseCase{ctrl: ctrl}
        mock.recorder = &amp;MockUserUseCaseMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUserUseCase) EXPECT() *MockUserUseCaseMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Delete mocks base method.
func (m *MockUserUseCase) Delete(ctx context.Context, entity *model.User) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Delete", ctx, entity)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Delete indicates an expected call of Delete.
func (mr *MockUserUseCaseMockRecorder) Delete(ctx, entity interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockUserUseCase)(nil).Delete), ctx, entity)
}</span>

// Insert mocks base method.
func (m *MockUserUseCase) Insert(ctx context.Context, entity *model.User) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Insert", ctx, entity)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Insert indicates an expected call of Insert.
func (mr *MockUserUseCaseMockRecorder) Insert(ctx, entity interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Insert", reflect.TypeOf((*MockUserUseCase)(nil).Insert), ctx, entity)
}</span>

// Select mocks base method.
func (m *MockUserUseCase) Select(ctx context.Context) ([]*model.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Select", ctx)
        ret0, _ := ret[0].([]*model.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Select indicates an expected call of Select.
func (mr *MockUserUseCaseMockRecorder) Select(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Select", reflect.TypeOf((*MockUserUseCase)(nil).Select), ctx)
}</span>

// Update mocks base method.
func (m *MockUserUseCase) Update(ctx context.Context, entity *model.User) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Update", ctx, entity)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Update indicates an expected call of Update.
func (mr *MockUserUseCaseMockRecorder) Update(ctx, entity interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockUserUseCase)(nil).Update), ctx, entity)
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">//go:generate mockgen -source=$GOFILE -destination=mock_$GOPACKAGE/mock_$GOFILE
package usecase

import (
        "context"

        recruitM "github.com/satorunooshie/swipe-shukatu/pkg/domain/model"
        recruitR "github.com/satorunooshie/swipe-shukatu/pkg/domain/repository"
)

type RecruitUseCase interface {
        Select(ctx context.Context) ([]*recruitM.Recruit, error)
        Insert(ctx context.Context, entity *recruitM.Recruit) error
        Update(ctx context.Context, entity *recruitM.Recruit) error
        Delete(ctx context.Context, entity *recruitM.Recruit) error
}

type recruitUseCase struct {
        recruitRepository recruitR.RecruitRepository
}

// NewRecruitUsecase
func NewRecruitUsecase(recruitR recruitR.RecruitRepository) RecruitUseCase <span class="cov0" title="0">{
        return &amp;recruitUseCase{
                recruitRepository: recruitR,
        }
}</span>

// Select
func (recruitU *recruitUseCase) Select(ctx context.Context) ([]*recruitM.Recruit, error) <span class="cov0" title="0">{
        recruits, err := recruitU.recruitRepository.Select(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return recruits, nil</span>
}

// Insert
func (recruitU *recruitUseCase) Insert(ctx context.Context, entity *recruitM.Recruit) error <span class="cov0" title="0">{
        err := recruitU.recruitRepository.Insert(ctx, entity)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Update
func (recruitU *recruitUseCase) Update(ctx context.Context, entity *recruitM.Recruit) error <span class="cov0" title="0">{
        err := recruitU.recruitRepository.Update(ctx, entity)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Delete
func (recruitU *recruitUseCase) Delete(ctx context.Context, entity *recruitM.Recruit) error <span class="cov0" title="0">{
        err := recruitU.recruitRepository.Delete(ctx, entity)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">//go:generate mockgen -source=$GOFILE -destination=mock_$GOPACKAGE/mock_$GOFILE
package usecase

import (
        "context"

        userM "github.com/satorunooshie/swipe-shukatu/pkg/domain/model"
        userR "github.com/satorunooshie/swipe-shukatu/pkg/domain/repository"
)

type UserUseCase interface {
        Select(ctx context.Context) ([]*userM.User, error)
        Insert(ctx context.Context, entity *userM.User) error
        Update(ctx context.Context, entity *userM.User) error
        Delete(ctx context.Context, entity *userM.User) error
}

type userUseCase struct {
        userRepository userR.UserRepository
}

// NewUserUsecase ...
func NewUserUsecase(userR userR.UserRepository) UserUseCase <span class="cov0" title="0">{
        return &amp;userUseCase{
                userRepository: userR,
        }
}</span>

// Select ...
func (userU *userUseCase) Select(ctx context.Context) ([]*userM.User, error) <span class="cov0" title="0">{
        users, err := userU.userRepository.Select(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return users, nil</span>
}

// Insert ...
func (userU *userUseCase) Insert(ctx context.Context, entity *userM.User) error <span class="cov0" title="0">{
        err := userU.userRepository.Insert(ctx, entity)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Update ...
func (userU *userUseCase) Update(ctx context.Context, entity *userM.User) error <span class="cov0" title="0">{
        err := userU.userRepository.Update(ctx, entity)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Delete ...
func (userU *userUseCase) Delete(ctx context.Context, entity *userM.User) error <span class="cov0" title="0">{
        err := userU.userRepository.Delete(ctx, entity)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
